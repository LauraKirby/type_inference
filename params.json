{
  "name": "Type Inference in Swift",
  "tagline": "A short document that explains Swift’s type-inference system and why developers should care.",
  "body": "## Prompt:\r\nWrite a short document that explains Swift’s type-inference system and why developers should care.\r\n\r\n## Documentation: Swift’s Type-inference System\r\nIn \"Part 1: Type Inference,\" we will cover the basics of Swift's type inference system by describing type safety and generic functions. In \"Part 2: Type Inference & Type Annotation,\" we will walk through an example that uses both type inference and type annotation for type casting.\r\n\r\n## Part 1: Type Inference\r\nIf you have experience with type safe languages such as Objective-C, Java or C#, you know that type must be annotated each time a new expression is created. In addition to type annotation, Swift uses type inference to identify a type. Type inference is the process by which the compiler can evaluate the values you provide and conclude the type of a particular expression. Type inference cleans up our source code by decreasing the need to write repetitive type identifiers that can be inferred by the compiler.\r\n\r\n#### Type Safety\r\nSwift is a type safe language and requires every expression to have a type at compile-time. If an expression is created and a type is not assigned, the compiler will crash and we will not be able to run our code. This requirement will prevent conflicting type crashes during run time.\r\n\r\n```swift\r\n// Create a variable and annotate the type as `String`.\r\nvar groundWater: String = \"sourced through springs and wells\"\r\n\r\n// Create a variable and allow Swift's type inference system to deduce the type `String`.\r\nvar drought = \"a shortage of water resulting from abnormally low rainfall\"\r\n```\r\n\r\n#### Generic Functions\r\nGeneric functions allow us to pass in any type to our function when it is called. Generic functions are defined with *type parameters*, meaning parameters that are annotated with a *placeholder* for a type instead of an *actual* type (e.g. `String`, `Int`). Type parameters allow the parameter type to be inferred by the argument type each time the function is called. Creating generic functions that rely on type inference allows us to write less code because we can reuse the same function for different argument types.\r\n\r\nThe placeholder for a type parameter is named and specified in angle brackets after the function name. Multiple type parameters can be implemented by writing a comma-separated list within the angle brackets.\r\n\r\n```swift\r\n// Define a generic function with two placeholder parameters.\r\n\r\nfunc printChosenColor<T,U>(a: T, b: U) {\r\n    print(\"You chose the color:\", a, b)\r\n}\r\n\r\nvar myColorDecimal = 5649055\r\nvar myColorName = \"purple\"\r\n\r\nprintChosenColor(myColorDecimal, b: myColorName)\r\n// You chose the color: 5649055 purple\r\n// a is inferred as type Int, while b is inferred as type String\r\n\r\nprintChosenColor(myColorName, b: myColorDecimal)\r\n// You chose the color: purple 5649055\r\n// a is inferred as type String, while b is inferred as type Int\r\n```\r\n\r\n## Part 2: Type Inference & Type Annotation\r\nAs seen in the section above, type inference allows us to write flexible code. Type annotation allows us to be explicit about acceptable types and is required in type casting. Type inference and type annotation can be used together to make our source code dynamic.\r\n\r\n#### Type Casting\r\nWhen working with a hierarchy of classes and subclasses we need to be explicit about acceptable types. Type casting can be used with classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy.\r\n\r\n```swift\r\n// Create a class called Plant.\r\nclass Plant {\r\n    var name: String\r\n    init(name: String) {\r\n        self.name = name\r\n    }\r\n}\r\n\r\n// Create a subclass of Plant called Perennial.\r\nclass Perennial: Plant {\r\n    var dormantSeason: String\r\n    init(name: String, dormantSeason: String) {\r\n        self.dormantSeason = dormantSeason\r\n        super.init(name: name)\r\n    }\r\n}\r\n\r\n// Create a subclass of Plant called Succulent.\r\nclass Succulent: Plant {\r\n    var waterStorage: String\r\n    init(name: String, waterStorage: String) {\r\n      self.waterStorage = waterStorage\r\n      super.init(name: name)\r\n    }\r\n}\r\n```\r\nWhen an array is composed of items with different classes, type inference will try to find a common super class.\r\n\r\n```swift\r\n// Create an array that will store an instance of Perennial and Succulent.\r\nlet myPlants = [\r\n    Perennial(name: \"Fern\", dormantSeason: \"winter\"),\r\n    Succulent(name: \"Burro's Tail\", waterStorage: \"leaves\")\r\n]\r\n\r\n// The `myPlants` array is composed of instances from a common super class `Plants`.  Array items in `myPlants` will be inferred as type `Plants`.\r\n```\r\nThe `as?` operator can be used when we try to downcast to an unknown subclass. If we are sure that the downcast will be successful, then we can use the `as!` operator.\r\n\r\n```swift\r\n// Create a function that will iterate over each item in myPlants, downcast each Plant instance to its subclass, and then access a property from its newly identified class.\r\n\r\nfunc downcastAndPrint(plants:[Plant]) {\r\n    for item in plants {\r\n        if let perennial = item as? Perennial {\r\n            print(\"A \\(perennial.name) will be dormant during \\(perennial.dormantSeason).\")\r\n        } else if let succulent = item as? Succulent {\r\n            print(\"A \\(succulent.name) stores water in its \\(succulent.waterStorage).\")\r\n        }\r\n    }\r\n}\r\n\r\ndowncastAndPrint(myPlants)\r\n```\r\n\r\nSwift's type inference system makes our source code readable and compact by decreasing the need to write repetitive type identifiers. Type inference plays a key role in the functionality of placeholder parameters, which permit the reusability of generic functions with different argument types. Type inference and type annotation can be used together to make our source code flexible and dynamic by permitting various types and downcasting others.\r\n\r\nSources:\r\n\r\n1. \"To Help Students Learn, Appeal to What They Value\" by Heidi A. Olinger, http://www.edutopia.org/blog/appeal-to-what-students-value-heidi-olinger\r\n\r\n2. \"Chunking Information for Instructional Design\" by Connie Malamed, http://theelearningcoach.com/elearning_design/chunking-information/\r\n\r\n3. \"Type Safety\" by Michael Hicks, http://www.pl-enthusiast.net/2014/08/05/type-safety/\r\n\r\n4. \"The Swift Programming Language (Swift 2.2)\", https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}